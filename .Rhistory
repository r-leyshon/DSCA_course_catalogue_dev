test
class(test)
class(test$created_at)
test_1 <- test$created_at
test_1
class(test_1)
str(test_1)
test <- lapply(all_created_dates, function(all_created_dates){strptime(all_created_dates, format = '%Y-%m-%dT%H:%M:%S')})
test <- lapply(all_created_dates, function(x){strptime(x, format = '%Y-%m-%dT%H:%M:%S')})
test
test <- lapply(all_created_dates, function(.){strptime(., format = '%Y-%m-%dT%H:%M:%S')})
test
test
test_1 <- test$created_at
str(test_1)
cbind.fill(output_dataframe, test_1)
test_2 <- cbind.fill(output_dataframe, test_1)
View(test_2)
test_1 <- as.character(test$created_at)
str(test_1)
test_2 <- cbind.fill(output_dataframe, test_1)
test
#apply the strptime function to the extracted dates. Need a custom funciton to handle the
#format argument when applying.
all_dates_posix <- lapply(all_created_dates, function(.){strptime(., format = '%Y-%m-%dT%H:%M:%S')})
#store as character vector for cbind.fill
test_1 <- as.character(all_dates_posix$created_at)
str(test_1)
#apply the strptime function to the extracted dates. Need a custom funciton to handle the
#format argument when applying.
created_dates_posix <- lapply(all_created_dates, function(.){strptime(., format = '%Y-%m-%dT%H:%M:%S')})
#store as character vector for cbind.fill
test_1 <- as.character(created_dates_posix$created_at)
str(test_1)
#store as character vector for cbind.fill
created_dates_character <- as.character(created_dates_posix$created_at)
#cbind back to output_dataframe
output_dataframe <- cbind.fill(output_dataframe, test_1)
View(output_dataframe)
names(output_dataframe)
colnames(output_dataframe)
colnames(output_dataframe)[3]
colnames(output_dataframe)[3] <- "created_date"
View(output_dataframe)
View(cbind.fill)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/munge/01_GET_repo_names.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/munge/02_GET_created_date.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/munge/02_GET_created_date.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/munge/01_GET_repo_names.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/munge/02_GET_created_date.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/munge/03_GET_last_updated.R', echo=TRUE)
remove(list = c('all_updated_dates',
'updated_dates_posix',
'updated_dates_character'
))
View(output_dataframe)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
View(output_dataframe)
parsed_course_pages <- lapply(output_dataframe$site_link, read_html)
output_dataframe[1,2]
read_html(output_dataframe[1,2])
read_html(output_dataframe[1,30])
read_html(output_dataframe[1,29])
read_html(output_dataframe[30,2])
read_html(output_dataframe[31,2])
parsed_course_pages <- lapply(output_dataframe$site_link, read_html)
parsed_course_pages <- lapply(output_dataframe[site_link], read_html)
parsed_course_pages <- lapply(output_dataframe[2], read_html)
parsed_course_pages <- lapply(output_dataframe[,2], read_html)
parsed_course_pages
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
View(output_dataframe)
View(output_dataframe)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/munge/01_GET_repo_names.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/munge/02_GET_created_date.R', echo=TRUE)
View(output_dataframe)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/munge/01_GET_repo_names.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/munge/02_GET_created_date.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/munge/03_GET_last_updated.R', echo=TRUE)
#parse and store all course pages as a nested list object
#amendment at version 1.1. error here when using $ operator to select column. index ref now working.
parsed_course_pages <- lapply(output_dataframe[,2], read_html)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
View(output_dataframe)
#only print if readmes are absent
if (any(is.na(output_dataframe[, 5]))) {
print(paste("There is no description available for: ",
output_dataframe$course_repo_names[is.na(output_dataframe[, 6])]
))
}
if (any(is.na(output_dataframe[, 6]))) {
print(paste("There is no description available for: ",
output_dataframe$course_repo_names[is.na(output_dataframe[, 6])]
))
}
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
View(req_content)
View(output_dataframe)
View(req_content)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
View(output_dataframe)
ProjectTemplate::migrate.project()
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
View(output_dataframe)
#select all html_url items and stack as dataframe
all_descriptions <- list.stack(list.select(req_content, description))
all_descriptions
#store as character vector for cbind.fill
description_character <- as.character(all_descriptions$description)
description_character
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
View(output_dataframe)
list.select(req_content, description)
list.stack(list.select(req_content, description))
list.select(req_content, description)
list.stack(list.select(req_content, description))
test <- list.stack(list.select(req_content, description))
View(test)
test1 <- list.select(req_content, description)
View(test1)
list.stack(test1)
as.character(test1)
test1 %>% unname()
test1 %>% unname() %>% unlist()
test1 %>% unname() %>% unlist() %>% as.character()
test1 %>% unlist() %>% as.character()
test1 %>% unlist()
test2 <- test1 %>% unlist()
test2
test1
test2
test2[1]
test2[2]
str_remove_all(test2, "description")
test3 <- str_remove_all(test2, "description")
test3
test1
unlist(test1, use.names=FALSE)
test1
test1[30]
unlist(test1[1:length(test1)], use.names=FALSE)
str(test1[30])
str(test1[[30]])
install.packages("purrr")
install.packages("purrr")
purrr::map(test1, as.character)
test2 <- purrr::map(test1, as.character)
View(test2)
list.stack(test2)
rlist::list.stack(test2)
class(test2)
test2 <- purrr::map(test1, unlist)
test2
class(test2)
list.stack(test2)
rlist::list.stack(test2)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
test <- list.stack(list.select(req_content, description))
test
test1 <- list.select(req_content, description)
test1
unlist(test1[1:length(test1)], use.names=FALSE)
length(test)
length(test1)
test2 <- purrr::map(test1, unlist)
test2
test2 <- purrr::map(test1, as.character)
test2
test2 <- purrr::map(test1, as.character) %>% unlist()
test2
class(test2)
#select all repo_descriptions
all_descriptions <- list.select(req_content, description)
#store as character vector for cbind.fill
description_character <- purrr::map(test1, as.character) %>% unlist()
#cbind back to output_dataframe
output_dataframe <- as.data.frame(cbind.fill(output_dataframe, description_character))
#rename column
colnames(output_dataframe)[6] <- "repo_description"
#only print if updated date is absent
if (any(is.na(output_dataframe[, 6]))) {
print(paste("There is no repo description available for: ",
output_dataframe$course_repo_names[is.na(output_dataframe[, 6])]
))
}
output_dataframe[4,6]
class(output_dataframe[4,6])
if (any(is.na(output_dataframe[, 6]) | is.null(output_dataframe[, 6]))) {
print(paste("There is no repo description available for: ",
output_dataframe$course_repo_names[is.na(output_dataframe[, 6])]
))
}
if (any(is.na(output_dataframe[, 6]) | output_dataframe[, 6] == "NULL")) {
print(paste("There is no repo description available for: ",
output_dataframe$course_repo_names[is.na(output_dataframe[, 6])]
))
}
output_dataframe[, 6] == "NULL"
if (any(is.na(output_dataframe[, 6]) | output_dataframe[, 6] == "NULL")) {
print(paste("There is no repo description available for: ",
output_dataframe$course_repo_names[is.na(output_dataframe[, 6]) | output_dataframe[, 6] == "NULL"]
))
}
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
#select all repo_descriptions
all_has_issues <- list.select(req_content, has_issues)
all_has_issues
#store as character vector for cbind.fill
has_issues_logical <- purrr::map(all_has_issues, as.logical) %>% unlist()
has_issues_logical
#cbind back to output_dataframe
output_dataframe <- as.data.frame(cbind.fill(output_dataframe, has_issues_logical))
#rename column
colnames(output_dataframe)[7] <- "has_issues"
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
View(output_dataframe)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
View(cbind.fill)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
View(output_dataframe)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
#store as character vector for cbind.fill
forks_count_integer <- purrr::map(all_forks_count, as.integer) %>% unlist()
forks_count_integer
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
View(output_dataframe)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
#select all repo_descriptions
all_license_names <- list.select(req_content, name)
all_license_names
#select all repo_descriptions
all_license_names <- list.select(req_content, key)
#select all repo_descriptions
all_license_names <- list.select(req_content, license)
all_license_names
#select all repo_descriptions
all_licenses <- list.select(req_content, license)
#select all license names
all_license_names <- list.select(all_licenses, name)
list.select(all_licenses, name)
list.select(all_licenses, spdx_id)
class(all_license_names)
all_licenses[1]
View(all_licenses)
all_licenses[[1]][["license"]][["name"]]
all_licenses[[30]][["license"]][["name"]]
all_licenses[[28]][["license"]][["name"]]
all_licenses[[15]][["license"]][["name"]]
test <- list.select(req_content[["license"]], name)
test
test <- list.select(req_content[["license"]], name)
test
test <- list.select(req_content[["license"]], 'name')
test <- list.select(all_licenses[["license"]], 'name')
test <- list.select(all_licenses[["license"]], name)
test <- list.select(all_licenses, name)
list.filter(req_content, "name")
list.filter(all_licenses, "name")
test <- list.filter(all_licenses, "name")
test1 <- list.filter(all_licenses, "name")
test1 <- sapply(req_content, '[', 'license')
test1
test1 <- sapply(all_licenses, '[', 'name')
test1
test1 <- sapply(all_licenses, '[', 'node_id')
test1
test1 <- apply(all_licenses, '[', 'node_id')
test1 <- lapply(all_licenses, '[', 'node_id')
test1
test1 <- lapply(all_licenses, '[', 'name')
test1
test1 <- lapply(all_licenses, '[[', 'name')
test1
all_licenses %>% unlist()
test <- all_licenses %>% unlist()
test[1]
test[2]
class(test)
test <- all_licenses %>% unname() %>% unlist()
class(test)
test[1]
test[2]
test <- all_licenses  %>% unlist()
#select all repo_descriptions
all_licenses <- list.select(req_content, license.name)
#select all repo_descriptions
all_licenses <- list.select(req_content, license)
#select all license names
test <- list.select(all_licenses, license.name)
test[grepl("license.name")]
test[grepl(test, "license.name")]
test[grep(test, "license.name")]
grep(test, "license.name")
grep(test[1], "license.name")
grep(test[2], "license.name")
grep(test[3], "license.name")
as.data.frame(test)
all_licenses
#select all repo_descriptions
all_licenses <- list.select(req_content, license$name)
all_licenses
#store as character vector for cbind.fill
license_name_text <- purrr::map(all_licenses, as.character) %>% unlist()
license_name_text
#cbind back to output_dataframe
output_dataframe <- as.data.frame(cbind.fill(output_dataframe, license_name_text))
#rename column
colnames(output_dataframe)[15] <- "license_name"
if (any(is.na(output_dataframe[, 15]) | output_dataframe[, 15] == "NULL")) {
print(paste("There is no license information for: ",
output_dataframe$course_repo_names[is.na(output_dataframe[, 15]) | output_dataframe[, 15] == "NULL"]
))
}
#only print if has issues is NA or "NULL"
if (any(is.na(output_dataframe[, 15]) | output_dataframe[, 15] == "NULL")) {
print(paste("There is no license information for: ",
output_dataframe$course_repo_names[is.na(output_dataframe[, 15]) | output_dataframe[, 15] == "NULL"]
))
}
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
#select all repo_descriptions
all_watchers <- list.select(req_content, watchers)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
View(output_dataframe)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
req_content[[1]][["svn_url"]]
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
output_dataframe$course_repo_names
grep("DSCA", output_dataframe$course_repo_names)
test <- output_dataframe[grep("DSCA", output_dataframe$course_repo_names)]
View(test)
test <- output_dataframe[grep("DSCA", output_dataframe$course_repo_names), ]
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
View(output_dataframe)
zip(zipfile = "course_catalogue", files = output_data, flags = " a -tzip",
zip = "C:\\Program Files\\7-Zip\\7Z")
zip(zipfile = "course_catalogue", files = output_data/, flags = " a -tzip",
zip = "C:\\Program Files\\7-Zip\\7Z")
# Read the 2 xlsx file names from output_data directory
xlsx_Files <- list.files(path = '/output_data', pattern = ".xlsx$")
xlsx_Files
# Read the 2 xlsx file names from output_data directory
xlsx_Files <- list.files(path = '/output_data', pattern = ".xls$")
xlsx_Files
# Read the 2 xlsx file names from output_data directory
xlsx_Files <- list.files(path = '/output_data', pattern = ".xls")
xlsx_Files
# Read the 2 xlsx file names from output_data directory
xlsx_Files <- list.files(path = '/output_data', pattern = ".xlsx")
xlsx_Files
list.files()
list.files("output_data")
list.files("output_data", pattern = ".xlsx")
# Read the 2 xlsx file names from output_data directory
xlsx_Files <- list.files(path = 'output_data')
xlsx_Files
zip(zipfile = "course_catalogue", files = xlsx_Files, flags = " a -tzip",
zip = "C:\\Program Files\\7-Zip\\7Z")
print("Hi")
?zip
zip(zipfile = "output_data/course_catalogue", files = xlsx_Files, flags = " a -tzip",
zip = "C:\\Program Files\\7-Zip\\7Z")
file.info("output_data/course_catalogue")
install.packages("zip")
zip(zipfile = "output_data/course_catalogue.zip", files = xlsx_Files, flags = " a -tzip",
zip = "C:\\Program Files\\7-Zip\\7Z")
zip::zip("output_data/course_catalogue.zip", xlsx_Files)
zip::zipr("output_data/course_catalogue.zip", xlsx_Files)
files2zip <- dir('output_data', full.names = TRUE)
files2zip
xlsx_Files
zip(zipfile = 'course_catalogue', files = files2zip)
zip::zipr("output_data/course_catalogue.zip", files2zip)
install.packages("gmailr")
library(gmailr)
use_secret_file("git_ignore/client_secret_gmail.json")
email_text <- "Automated email sent from dsca_course_catalogue_dev - master. Please find attached
the latest version of DSCA course catalogue and metadata for all DSC open repos."
source("git_ignore/email_addresses.R")
#purpose of script: Automated email of zipped output data
#load cached email addresses
source("git_ignore/email_addresses.R")
email_complete <- mime() %>%
to(recipients) %>%
from(from_address) %>%
subject("DSCA course catalogue update attached") %>%
text_body(email_text) %>%
attach_part(email_text) %>%
attach_file("output_data/course_catalogue")
email_complete <- gm_mime() %>%
gm_to(recipients) %>%
gm_from(from_address) %>%
gm_subject("DSCA course catalogue update attached") %>%
gm_text_body(email_text) %>%
gm_attach_part(email_text) %>%
gm_attach_file("output_data/course_catalogue")
email_complete <- gm_mime() %>%
gm_to(recipients) %>%
gm_from(from_address) %>%
gm_subject("DSCA course catalogue update attached") %>%
gm_text_body(email_text) %>%
gm_attach_part(email_text)
email_complete <- gm_mime() %>%
gm_to(recipients) %>%
gm_from(from_address) %>%
gm_subject("DSCA course catalogue update attached") %>%
gm_text_body(email_text) %>%
gm_attach_part(email_text) %>%
gm_attach_file("output_data/course_catalogue.zip")
send_message(email_complete)
gm_send_message(email_complete)
gm_auth_configure()
gm_auth_configure(
use_secret_file("git_ignore/client_secret_gmail.json")
)
?gm_auth_configure
gm_auth_configure(path = "git_ignore/client_secret_gmail.json")
gm_send_message(email_complete)
gm_send_message(email_complete)
gm_auth()
source('~/dsca_course_catalogue_dev/munge/27_gmailr.R', echo=TRUE)
gm_send_message(email_complete)
#purpose of script: Automated email of zipped output data
#load cached email addresses
source("git_ignore/email_addresses.R")
email_complete <- gm_mime() %>%
gm_to(recipients) %>%
gm_from(from_address) %>%
gm_subject("DSCA course catalogue update attached") %>%
gm_text_body(email_text) %>%
gm_attach_part(email_text) %>%
gm_attach_file("output_data/course_catalogue.zip")
gm_send_message(email_complete)
#purpose of script: Automated email of zipped output data
#load cached email addresses
source("git_ignore/email_addresses.R")
email_complete <- gm_mime() %>%
gm_to(recipients) %>%
gm_from(from_address) %>%
gm_subject("DSCA course catalogue update attached") %>%
gm_text_body(email_text) %>%
gm_attach_part(email_text) %>%
gm_attach_file("output_data/course_catalogue.zip")
gm_send_message(email_complete)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/munge/27_gmailr.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
View(output_dataframe)
#apply the function to extract course descriptions from the parsed course list
course_desc_list <- lapply(parsed_course_pages, FUN = extract_course_description)
#extract the length of all elements in the course description list
n.obs <- sapply(course_desc_list, length)
#create a sequence based on the maximum number of observations
seq.max <- seq_len(max(n.obs))
#apply the subsetting function over each element in the list, using the seq.max to prevent
#recycling of variable vector length
description_matrix <- t(sapply(course_desc_list, "[", i = seq.max))
#This can then be cbind'ed to the output_dataframe.
output_dataframe <- cbind(output_dataframe, description_matrix)
#put a prefix in front of all text columns present
colnames(output_dataframe)[24:ncol(output_dataframe)] <-  paste("Paragraph", colnames(output_dataframe)[24:ncol(output_dataframe)])
output_dataframe[output_dataframe == "Go back"] <- NA
remove(list = c('course_desc_list',
'n.obs',
'seq.max',
'description_matrix',
'extract_course_description',
'parsed_course_pages'))
#only print if readmes are absent
if (any(is.na(output_dataframe[, 24]))) {
print(paste("There is no readme description available for: ",
output_dataframe$course_repo_names[is.na(output_dataframe[, 24])]
))
}
View(output_dataframe)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
View(output_dataframe)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
lifecycle::last_warnings()
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
View(output_dataframe)
View(extract_course_name)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
# Read the 2 xlsx file names from output_data directory
files2zip <- dir('output_data', full.names = TRUE)
#zip files to folder
zip::zipr("output_data/course_catalogue.zip", files2zip)
todays_date <- Sys.Date()
todays_date
str(todays_date)
class(todays_date)
#zip files to folder
zip::zipr(paste0("output_data/course_catalogue_", todays_date, ".zip"), files2zip)
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
remove(list = 'files2zip',
'todays_date')
source('~/dsca_course_catalogue_dev/src/initialise.R', echo=TRUE)
